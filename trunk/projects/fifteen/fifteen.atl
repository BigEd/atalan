; Little Fifteen
; no (c) MMX
; Author: Jakub Husak
; GfX: various properties
; GFX tool: Gimp
; Music tool: RMT
; Stencil font
;
; This is Public Domain.
; 
; Not so simple Atalan game.
; But the development was really fast: 4 days with graphics and music.
; Well, SuperFortuna took 2 months...
; Greetings 4 All, especially 4 Rudolf Kudla, author of Atalan.
;
; There is very tight memory gap between end of code and addres $93e0,
; which is used by the RMT player.
; The code is compiled with optimizations off, because of some bugs in optimizer.

; This HACK is for passing tables into procedures.
mem@$0000:array(60000) of byte

; Screen 208 lines long (well, 200, but last 8 are the first 8 repeated)
screen@$A0b0:array(39, 199) of byte

; GR8 dl.
const dl:array of byte = ( 2 times $70, $4f,  screen ,
	32 times $f,
	$8f,
	18 times $f
	$8f,
	12 times $f ,
	$8f,
	29 times $f ,
	$8f
	$f $f
	$4f , 0, $B0 ,
	40  times $f,
	$8f
	60  times $f,
	$4f screen
	7 times $f
	$41, dl
	)
	
vcnt@$613:byte

set_col:dli =
	if vcnt = 0
		inc vcnt
		wait'line
		player_col2(3) = $9e
		COLPF(3) = $96
		player_x(3)=180
		missile_x(2)=166
		missile_x(3)=172
		wait'line
		player_col2(3) = $8e
		COLPF(3) = $86
		wait'line
		player_col2(3) = $5e
		COLPF(3) = $56
		wait'line
		player_col2(3) = $4e
		COLPF(3) = $46
	else if vcnt = 1
		wait'line
		COLPF(3) = $4e
		player_x(3)=166
		missile_x(2)=192
		missile_x(3)=200
		inc vcnt
	else if vcnt = 2
		wait'line
		player_col2(3) = $4c
		wait'line
		player_col2(3) = $4a
		wait'line
		player_col2(3) = $48
		wait'line
		player_col2(3) = $46
		wait'line
		player_col2(3) = $44
		wait'line
		player_col2(3) = $42
		inc vcnt
	else if vcnt = 3
		wait'line
		player_col2(3) = $56
		COLPF(3) = $56
		wait'line
		COLPF(3) = $84
		player_col2(3) = $86
		wait'line
		COLPF(3) = $94
		player_col2(3) = $96
		inc vcnt
	else if vcnt = 4
		wait'line
		COLPF(3) = $9a
		player_col2(3) = $9c
		inc vcnt
; Guess what is this.	
pmg_mem@$9c00:array(0..1023) of byte

textbuf@$a000:array(14,0)
besttime@$a010:array(14,0)

playfield@$9d70:array(3,3) of byte

const
	D_UP=0
	D_RIGHT=1
	D_DOWN=2
	D_LEFT=3
	T_EMPTY=$f
	XOFF=1
	YOFF=8

; Fixed variables, this leads to leave some room for automatic temporal variables.
; There are 128-230 allocated locations on ZP.
; 237-255 are used by RMT player
i@$600:byte
j@$601:byte
k@$602:0..3
l@$603:0..3

const buf1: array(23, 191) = file "einstein-tongue.pbm"
const buf2: array(23, 191) = file "miner.pbm"
const buf3: array(23, 191) = file "johnromero.pbm"
const buf4: array(23, 191) = file "clinteastwood.pbm"
const leafh: array(47) = file "leafhoriz.pbm"
const leafv: array(47) = file "leafvert.pbm"
const mains: array(2800) = file "15.pbm"
const fonts: array(1024) = file "STENCIL.FNT"

xbtmp@$604:byte
ybtmp@$605:byte
xctmp@$606:card
yctmp@$608:card
ctmp1@$60a:card
bptr@$60c:card
btmp1@$60e:byte
btmp2@$60f:byte

CONSOL@53279:byte

mus_init@$9700: proc
mus_play@$9703: proc
mus_p3@$9706: proc
mus_silence@$9709:proc
mus_setpokey@$970c:proc

dir@$610:byte
play@$611:byte
piccnt@$612:byte= RANDOM and 3

tsec@$614:byte
tdsec@$615:byte
tmin@$616:byte
tdmin@$617:byte
moves@$618:card
bmoves@$61a:card
currcol@$61c:byte
currentbuf@$61d:adr
tmp@$61f:byte
xtilesize@$620:byte
ytilesize@$621:byte

sleep: proc time:byte =
	tmp = timer
	tmp = tmp + time
	while timer<>tmp


copyblock: proc srcbm:adr xbm:byte ybm:card wbm:byte xscr:byte yscr:byte xsize:byte ysize:byte=
	bptr(0)=srcbm(0)
	bptr(1)=srcbm(1)
	i=0
	while i<xsize 
		; destination coords
		xbtmp=i
		xbtmp=xbtmp+xscr
		ybtmp=yscr
		; source coords
		xctmp=xbm+i
		yctmp=ybm
		; addr of source bitmaps
		ctmp1 = bptr
		ctmp1= ctmp1+ xctmp
		ctmp1= ctmp1+ yctmp
		for j:1..ysize
			screen(xbtmp,ybtmp)=mem(ctmp1)
			ctmp1 = ctmp1 + wbm
			inc ybtmp

		inc i

; before call text must be in textbuf array
text:proc xt:byte yt:byte len:byte=
	ii:byte=0
	while ii<len
		ctmp1=textbuf(ii)
		ctmp1=ctmp1*8
		btmp1= xt+ii
		copyblock fonts 0 ctmp1 1 btmp1 yt 1 8
		inc ii
		

copytile: proc xbm:byte ybm:byte xscr:byte yscr:byte xsize:byte ysize:byte=
	ctmp1=ybm
	ctmp1=ctmp1*48*24
	xbm=xbm*6
	copyblock currentbuf xbm ctmp1 24 xscr yscr xsize ysize

eraserect: proc xscr:byte yscr:byte width:byte height:byte  =
	i=0
	while i<width
		xbtmp=i+xscr
		ybtmp=yscr
		j=0
		while j<height
			screen(xbtmp,ybtmp)=$ff
			inc ybtmp
			inc j
		inc i

findempty: proc >x:byte >y:byte =
	x=0
	y=0
	for k
		for l
			if playfield(k,l) = T_EMPTY
				x=k
				y=l
	

gettile:proc tile:byte >tx:byte >ty:byte=
	ty = tile and 3
	tx = tile / 4
	tx = tx and 3
	
showboard: proc =
	for k
		for l
			xbtmp = 6*k+XOFF
			ybtmp = 48*l+YOFF
			tile = playfield(k,l)
			if tile <> T_EMPTY
				i,j=gettile tile
				copytile i j xbtmp ybtmp 6 48
			else
				eraserect  xbtmp ybtmp 6 48
	

movetile: proc xs:byte ys:byte m:byte show:byte =
	tile:byte
	xoffset:byte
	yoffset:byte
	xoffset=1
	yoffset=1
	AUDC1=$22
	if m = D_UP
		if ys<3
			yoffset=2

	if m = D_RIGHT
		if xs>0
			xoffset=0

	if m = D_DOWN
		if ys>0
			yoffset=0

	if m = D_LEFT
		if xs<3
			xoffset=2

	if xoffset <>1 or yoffset <>1
		;no rule: playfield(xs,ys)=playfield(xs+xoffset-1,ys+yoffset-1)
		xbtmp=xs-1+xoffset
		ybtmp=ys-1+yoffset
		playfield(xs,ys)=playfield(xbtmp,ybtmp)
		playfield(xbtmp,ybtmp)=T_EMPTY
		inc moves
		if moves > 999 moves=999

	xoffset=0
	yoffset=0
	if show >0
		z=0
		if show=2 z=5
		while z<6
			;for z: 0..5
			xbtmp=xs*6+XOFF
			ybtmp=ys*48+YOFF
			AUDF1=z+xs
			xtilesize=6
			ytilesize=48
			
			if m = D_LEFT
				if xs<3
					xoffset=5-z
					yoffset=0
					btmp1 = xbtmp+6
					btmp1 = btmp1+xoffset
					btmp2=ybtmp+yoffset
					xtilesize=1

			if m = D_DOWN
				if ys>0
					yoffset=z-5
					yoffset = yoffset * 8
					xoffset=0
					btmp1=xbtmp+xoffset
					btmp2=ybtmp+yoffset
					btmp2=btmp2-8
					if z=5 btmp2 = btmp2-40
					ytilesize=8
			if m = D_RIGHT
				if xs>0
					xoffset=z-5
					yoffset=0
					btmp1=xbtmp+xoffset
					dec btmp1
					if z=5 btmp1 = btmp1-5
					btmp2=ybtmp+yoffset
					xtilesize=1

			if m = D_UP
				if ys<3
					yoffset=5-z
					yoffset = yoffset * 8
					xoffset=0
					btmp1=xbtmp+xoffset
					btmp2=ybtmp+yoffset
					btmp2=btmp2+48
					ytilesize=8

			if xtilesize<>6 or ytilesize<>48
				if z=5 xtilesize=6 ytilesize=48 
				eraserect btmp1 btmp2 xtilesize ytilesize
				

			tile = playfield(xs,ys)
			if tile <> T_EMPTY
				if show >0
					k,l = gettile tile
					btmp1=xs*6
					btmp1=btmp1+XOFF
					btmp1=btmp1+xoffset
					btmp2=ys*48
					btmp2=btmp2+YOFF
					btmp2=btmp2+yoffset
					copytile k l btmp1 btmp2 6 48
			inc z
	AUDC1=0

	
clrscr:proc =
	i=0
	while i<40
		j=0
		while j<200
			screen(i,j)=255
			inc j
		inc i


changepicture: proc >c:byte =
	if piccnt=0
		currentbuf=buf1
		c=$1c
	if piccnt=1
		currentbuf=buf2
		c=$0e

	if piccnt=2
		currentbuf=buf3
		c=$3a
	if piccnt=3
		currentbuf=buf4
		c=$7a

	inc piccnt
	if piccnt>=4 piccnt=0

	

countgoodtiles: proc >res:byte=
	res=0
	for k
		for l
			tile=k*4
			tile=tile+l
			if playfield(k,l) = tile inc res

inittiles: proc =
	for k
		for l
			tile=k*4
			tile=tile+l
			playfield(k,l)=tile

setboardcolor: proc col:byte =
	player_color(0)=col
	player_color(1)=col
	player_color(2)=col


changecolor: proc col:byte =
	btmp1=col and $f
	btmp2=col and $f0

	xbtmp=currcol and $f
	ybtmp=currcol and $f0

	if xbtmp < btmp1 ; fade in
		while btmp1 > xbtmp
			xbtmp = xbtmp + 2
			currcol = btmp2
			currcol = currcol + xbtmp
			setboardcolor currcol
			sleep 1
	else ; fade out
		while btmp1 < xbtmp
			xbtmp = xbtmp -2
			currcol = ybtmp
			currcol = currcol + xbtmp
			setboardcolor currcol
			sleep 1


drawmainscreen: proc=
	copyblock mains 0 0 14 26 0 14 200
	j=0
	for i:0..3 
		xbtmp=i*6
		inc xbtmp
		copyblock leafh 0 0 6 xbtmp 0 6 8
		xbtmp=8+j
		copyblock leafv 0 0 1 0 xbtmp 1 48
		xbtmp=8+j
		copyblock leafv 0 0 1 25 xbtmp 1 48
		j=j+48

	tmp:byte = changepicture
	showboard
	currcol=0
	changecolor tmp

shuffletiles: proc =
	c:byte=0
	loop@
	dir=RANDOM and 3
	x,y=findempty
	movetile x y dir 2
	cnt=countgoodtiles
	if c<50 inc c
	if cnt>2 or c<50 goto loop
		

cycle:vbi =
	if play = 1
		mus_play
	vcnt=0

fillpmg: proc =
	ctmp1 = $180
	; while ctmp1<$400 - no rule
	while ctmp1<=$3ff
		pmg_mem(i)=$0
		inc ctmp1

	for i:16..111
		ctmp1=$200
		ctmp1 = ctmp1+i
		pmg_mem(ctmp1)=$ff
		ctmp1=ctmp1+ $80
		pmg_mem(ctmp1)=$ff
		ctmp1=ctmp1+ $80
		pmg_mem(ctmp1)=$ff
		ctmp1=ctmp1+ $80

	for i:12..115
		ctmp1=$180
		ctmp1=ctmp1 + i
		pmg_mem(ctmp1)=$ff
		ctmp1=ctmp1+ $200
		pmg_mem(ctmp1)=$fe

	for i:75..79
		ctmp1=$380
		ctmp1= ctmp1+ i
		pmg_mem(ctmp1)=$00

windowpmg:proc =
	; this compiles wrong!
	;for i:60..72
		;ctmp1=$200 + i
		;pmg_mem(ctmp1)=$55
	for i:0..17
		ctmp1=$237
		ctmp1 = ctmp1 +i
		pmg_mem(ctmp1)=$fc
		ctmp1 = ctmp1 +$80
		pmg_mem(ctmp1)=$0
		ctmp1 = ctmp1 +$80
		pmg_mem(ctmp1)=$3f

setpmg: proc=

	fillpmg

	PMBASE= $9c
	GRACTL=3

	GTICTLS=$18

	player_x(0)=52
	player_x(1)=84
	player_x(2)=116
	player_x(3)=166
	player_size(0)=3
	player_size(1)=3
	player_size(2)=3
	player_size(3)=3
	missile_x(0)=152
	missile_x(1)=160
	player_x(3)=166
	missile_x(2)=192
	missile_x(3)=200
	player_color(3)=$98
	COLOR0(3)=$96
	missile_size=$ff
	DMACTL =  $2e

	; cegfaultplayer_pos(0)=32
	

start_timer:proc =
	timer=0
	tsec=0
	tdsec=0
	tmin=0
	tdmin=0

update_timer:proc =
	
	if timer>49
		timer = timer -50
		inc tsec

	if tsec=10
		tsec=0
		inc tdsec

	if tdsec=6
		tdsec=0
		inc tmin

	if tmin=10
		tmin=0
		inc tdmin

	if tdmin=6
		tdmin=5
		tmin=9
		tdsec=5
		tsec=9

drawbesttime:proc =
	if besttime(0,0) <> 0
		tcnt:byte
		tcnt=0
		while tcnt<14
			textbuf(tcnt)=besttime(tcnt)
			inc tcnt
		text 26 181 14

		textbuf(0,0)="IN [bmoves] MOVES!   "
		text 27 192 13


initscreen: proc=

	DMACTL=0
	sdlstl = dl
	currentbuf=buf1
	
	;textbuf(0,0)="OPTION:shuffle"
	;text 26 167 14

	mus_setpokey

	setpmg
	play=0
	on'vbi cycle
	on'dli set_col

titlescreen: proc=
	DMACTL=0
	clrscr
	piccnt = RANDOM and 3
	inittiles
	drawmainscreen
	fillpmg
	DMACTL =  $2e

	mus_setpokey
	CH=62

	COLOR0(1) = $c0
	COLOR0(2) = $c8
	COLOR0(4) = $c0

	drawbesttime

	loop@
	if CH = 28  ; ESC 
		CH = none
		ctmp=countgoodtiles
		if ctmp<16
			ctmp=currcol
			changecolor 0
			inittiles
			showboard
			changecolor ctmp

	if CH=62
		CH = none
		if play = 1
			mus_silence
			play = 0
		else
			_x= $0
			_y= $9a
			mus_init
			play=1
			
	if CONSOL = 6
		shuffletiles
		showboard
		goto loop

	if CONSOL = 5
		changecolor 0
		btmp1 = changepicture
		showboard
		changecolor btmp1
		goto loop


	if CONSOL <> 3
		goto loop

game: proc=

	; GAME INIT
	showboard
	play=0
	mus_silence
	eraserect 26 140 14 60

	cnt=countgoodtiles
	if cnt=16 shuffletiles showboard
	moves=0
	start_timer

	drawbesttime
	; MAIN GAME LOOP
	gameloop@
	CH = none
	
	cnt=countgoodtiles
	textbuf(0,0)="Good tiles:[cnt] "
	text 27 141 13

	update_timer
	textbuf(0,0)="Time: [tdmin][tmin]:[tdsec][tsec]"
	text 27 152 11

	if cnt=16
		textbuf(0,0)="            "
		text 7 86 12
		text 7 102 12
		text 7 114 12
		windowpmg
		textbuf(0,0)=" Well done! "
		text 7 94 12
		textbuf(0,0)=" Time:[tdmin][tmin]:[tdsec][tsec] "
		text 7 106 12
		if moves<bmoves
			besttime(0,0)="BESTTIME:[tdmin][tmin]:[tdsec][tsec]"
			sleep 100
			textbuf(0,0)=" NEW RECORD!"
			text 7 94 12
			textbuf(0,0)=" [moves] MOVES!    "
			text 7 106 12
			bmoves=moves
			dir=0
			AUDC1=$68
			while dir<200
				AUDF1=dir
				setboardcolor RANDOM
				sleep 1
				inc dir

			AUDC1=0
			setboardcolor currcol
			dir=0
		else
			sleep 200
			
		CH=28
		goto gameend

	textbuf(0,0)="Moves: [moves]     "
	text 27 163 12

	ss:stick'state = STICK(0)

	dir=0
	if ss = 14 dir = 1
	if ss = 7  dir = 2
	if ss = 13 dir = 3
	if ss = 11 dir = 4
	if dir <> 0 
		x,y=findempty
		dec dir
		movetile x y dir 1
		dir=0
		sleep 1

	if CH <> 28 goto gameloop  ; ESC 

	gameend@

	CH = none


initscreen
besttime(0)=0
bmoves=999
while 1
	titlescreen
	game


		
