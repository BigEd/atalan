;********************************
;ATALAN ATARI Platform definition
;********************************

in timer@20:byte

;***********************
;Random number generator
;***********************
;
;This read register provides random numbers from 0 to 255.
;To get smaller ranges, use mod.
;
;Correct method for getting random number from min..max-1 is 
;   min + RANDOM * max / 256
;

in RANDOM@$D20A:0..255

;***********************
;Fonts
;***********************

;Font is 1024 bytes (128 chars, 8 bytes per character) aligned on one-kb boundary
;Font will be usually defined using const array and file initializer.
;To use such font use set'font procedure.

;:::
;const myfont:font = file "file.fnt"
;set'font myfont	    
;:::

type font@1024:array(1023)

CHBAS@756:byte	;CHBAS register contains hi byte of font address              

set'font:macro(x) =
	chbas = hi x


;*********************
;Screen editor
;*********************
LMARGN@82:byte
RMARGN@83:byte

;Screen position

in VCOUNT@$D40B:0..155		;for PAL machine
out WSYNC@$D40A:byte

;Wait for drawn line.
;As it is not important, what value gets written to WSYNC register, we write register A,
;without first initializing it.

wait'line:macro =
  WSYNC = _a

;Joysticks & paddles

in button'state:enum (pressed = 0, not'pressed = 1)
in STRIG@644:array(0..3) of button'state		;Set to 1 when joystick button is not pushed, 0 if pushed
;in STRIG0@644:button'state		;Set to 1 when joystick button is not pushed, 0 if pushed
;in STRIG1@645:button'state

type stick'state:enum (
	left = 11
	right = 7
	up    = 14
	down  = 13
	)

in STICK@632:array(0..3) of stick'state

; DMA

DMACTL@559:byte

color:0..255
	Black                    =   0
	Rust                     =  16
	Red'orange               =  32
	Dark'orange              =  48
	Red                      =  64
	Dark'lavender            =  80
	Cobalt'blue              =  96
	Ultramarine'blue         = 112
	Medium'blue              = 128
	Dark'blue                = 144
	Blue'grey                = 166
	Olive'green              = 176
	Medium'green             = 192
	Dark'green               = 208
	Orange'green             = 224
	Orange                   = 240
	White                    = 15
	
;Colors

out COLOR0@$02C4:array(5) of color
out COLPF@$d016:array(0..4) of color
out COLBK@$d01a:color			;is alias for COLPF(4)

;Player-missile graphics


out player_size@$d008:array(3) of byte
out player_x@$d000:array(3) of byte
out player_gfx@$d00d:array(3) of byte
player_color@704:array(3) of color			;shadow (slow) color
out player_col2@$d012:array(3) of color

out missile_size@$d00c:byte
out missile_x@$d004:array(3) of byte

out GRACTL@$d01d:byte

;Sound

out AUDF1@$D200:byte   ; audio 1 freq.      
out AUDC1@$D201:byte   ; audio 1 control    
out AUDCTL@$D208:byte  ; audio control
out SKCTL@$d20f:byte   ; audio control   


;Keyboard

key:enum
  Q = 47
  none = 255

in CH@764:key  ;last pressed character

;wait'key:macro =
;	CH = none
;	until CH <> none
;  CH = none

;end

;*** DISPLAY LISTS

dl_command:enum
	BLANK1  = 0
	END     = 1      
	BLANK2  = $10
	BLANK3  = $20
	BLANK4  = $30
	BLANK5  = $40
	BLANK6  = $50
	BLANK7  = $60
	BLANK8  = $70

	JMP     = $01
	CHR0    = $02
		
	HSCROLL = $10
	VSCROLL = $20
	LMS     = $40
	DLI     = $80
	NEXT    = $41		;END + LMS

out SDLSTL@$230:adr
	
;Display List Interrupt

;dli is type of procedure used to implement the DLI.

type dli:interrupt
out NMIEN@$D40E:byte
out VDSLST@$200:adr of dli

;There must be special rules to generate DLI routines.

rule proc %A:dli = "%A .proc" "   pha" "   txa" "   pha" "   tya" "   pha"
rule endproc %A:dli = "   pla" "   tay" "   pla" "   tax" "   pla" "   rti" ".endp"

on'dli:macro x:adr of dli =
	VDSLST = x
	NMIEN = $c0

;VBI

type vbi:interrupt
rule proc %A:vbi = "%A .proc"
rule endproc %A:vbi = "   jmp $e462" ".endp"

out VVBLKD@$0224:adr of vbi

;Macro to set up VBI.
;We use deferred VBI vector.
;TODO: Make it safe using system routines.

on'vbi:macro x:adr of vbi =
	VVBLKD = x

;_yx:adr
;setvbv@$E45C:proc type:enum (immediate = 6, deffered = 7) _yx:adr of vbi
;rule let_adr _yx, %A = instr
;	lo _y, %A
;	hi _x, %A

;DOS Vector
DOSVEC@10:card

DOS:macro =
	goto DOSVEC

rule prologue  = "   org $2e0" "   dta a($2000)" "   org $2000"
rule epilogue  = "   jmp *" "   icl 'atari.asm'"
rule line      = ";(%1) %2"
 	