;ATALAN Language system definition file
;This file is always loaded as first file by the compiler.

;system object is used to define internal variables used by Atalan system. 

system:
	processor: ()  ;cpu: type
	interrupt: type fn -> ()
	
;===
;CPU
;===

;Variables of type CPU are used to define registers, types and rules supported by given CPU.
		
;==========
;Interrupts
;==========

;All procedures based on type system.interrupt are considered to be implementation
;of some interrupt.
;As such, they will not share local variables with other, normal procedures or
;other types of interrupt.
;Actual interrupt types are defined by respective platforms.

;interrupt: type proc

;============
;Boolean type
;============

;IDEA: To define type, we may use double colon. Meaning there would be an identifier before the type, but it is not.
;      Maybe we may use -> to define the type (meaning this is the direct result of the name

bool: type
	• false: 0
	• true:  1

;Idea: any type may be defined using bullet.
;• 10..20
;byte: • 0..255
;This is nice, but: bullet specifies we declare named option, so it is not possible to use it
;However, what if there is only one option? That does not make such a good sense.
 

;=================
;Predefined macros
;=================

inc: macro x -> () 
	x = x + 1

dec: macro x -> ()
	x = x - 1

swap: macro x, y -> ()
	t = x
	x = y
	y = t

abs: macro x -> y
	y = x
	if x < 0 then y = -x

;abs: fn x -> if x >= 0 then x else -x

min: macro x,y -> z 
	z = x
	if z > y then z = y
	
max: macro x,y -> z
	z = x
	if z < y then z = y

	
;Support for array initialization 
;a() = 0
;a(10..20) = 13

;rule A:array of %B(%C..%D) = %E:%B -> macro
;	for i:%C..%D %A#i = %E

;Assign array to specified position
;a(5) = 3,4,5,6

;rule %A:array of %B(%C) = %E:array of %B(%F..%G) -> macro
;	j = %C
;	for i:%F..%G 
;		%A#j = %E#i
;		inc j

;Rules for translating logical operators in conditions.

rule if [A] or [B] goto [C] ->
   if %A goto %C
   if %B goto %C

rule if [A] and [B] goto [C] ->
   if %A 
      if %B goto %C

rule if not(either [A] or [B]) goto [C] ->
   x = 0
   if %A x = 1
   if %B
      if x = 1 goto %C
   else
      if x = 0 goto %C

