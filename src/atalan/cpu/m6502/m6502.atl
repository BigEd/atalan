;ATALAN definitions for 6502 processor
;This is include file automatically included by Atalan compiler.

type
   byte:0..255
   card:0..65535
   int:-32768..32767
   long:0..$ffffff
   sbyte:-128..127
   byte1:byte() or sbyte()
   byte2:card() or int()
   byte2a:byte2 or adr
   byte1arr:array(card) of byte1
   _byte1arr2D:array(card,card) of byte1

;==============================
;Definition of type allocations
;==============================

;rule alloc %A:0..255  = ".ds 1"

rule alloc %A:struct(), %B                         = "   .ds %B"
rule alloc %A:array(card) of byte1, %B            = "   .ds %B"
rule alloc %A:array(byte) of card, %B            = "%A_lo:" "   .ds %B" "%A_hi:" "   .ds %B" 
rule alloc %A:array(byte,byte) of byte1, %B, %C   = "   .ds %B*%C"
rule alloc %A:byte                               = "   .ds 1"
rule alloc %A:card                               = "   .ds 2"
rule alloc %A:long                               = "   .ds 3"
rule alloc %A:adr                                = "   .ds 2"
rule alloc %A:-128..127                          = "   .ds 1"
rule alloc %A:int                                = "   .ds 2"

;Define cpu registers.
;Any variable defined in cpu scope is considered a register.

CPU:scope =
	a:0..255
	x,y:0..255
	c,z,v,n:0..1	
	ac@(a,c)
	azn@(a,z,n)
	as@(a,c,z,n,v)	; this is set of flags used for result of adc, sbc
	cznv@(c,z,n,v)
	in void:0..255  ;This is special variable used to implement touch instructions.

	
;========================
;Temporary variables
;========================

;_stdbuf is used to format decimal numbers. Therefore it must be as big as number of decimal
;digits in biggest supported number.
;We do not assign an address to the buffer, so platform may set the address 
;of the buffer using _stdbuf@<adr>. If it will not, compiler will assign the address. 

_stdbuf:array(0..15) of byte
_arr:adr
_putchr_proc_adr:adr			;address of print procedure

;TODO: Temporary variables should be allocated dynamically
_TEMPW1@$32:CARD
_TEMPW2@$34:CARD
_TEMPL1@$70:CARD		;Should be: 0..$7fffffff

;Compiler macros
;These macros define available operators.

;We define some basic macro types (binary operator, relational operator etc.,
;so we do not need to repeat the definition again and again.

;binary:macro(a b r)   ; it is possible to enclose the arguments to parenthesis
;relop:macro a b lbl	  ; but it is optional

;Operator macros map the operators to compiler instructions.
;Compiler instructions are sort of pseudo machine language

;Arithmetic operators
;Note, how the @ defines operator priority.
;It is possible only for macros, for procedures @ defines address of the procedure.

;"+"@4:binary      = #add r,a,b
;"-"@4:binary      = #sub r,a,b
;"*"@10:binary     = #mul r,a,b
;"/"@10:binary     = #div r,a,b
;"("@1:macro		  = #begin
;")"@1:macro		  = #end
 
;Compiler transformation rules
;  
;There rules operate on list of compiler instructions and prepare them
;for emitting instructions.
;
;If the part before = matches input instructions, instructions from the right
;size od the rule are generated to output.
;
;Matching rules:
;  name		Variable name, input rule must reference same variable (register)
;  :type    Argument or result must match the type
;  @        Argument must be variable (not constant)
;  <int>    Integer constant - concrete value is matched
;
;Output arguments:
;   %0		Result
;   %1  argument 1 
;   %2  argument 2

;TODO: Rule for add 0, mul 1, div 1, sub 0

;type long:0..$7fffffff

;*********** Let

rule let %A:byte, %B:byte = instr
  let a,%B
  let %A,a
   
;signed byte assignment
;We cannot use byte1 to define this, as we do not allow assigning from signed to unsigned and vice versa
rule let %A:sbyte, %B:sbyte = instr
  let a,%B
  let %A,a

;===== Signed 2-bytes (s16)

rule let %A:int,%B:int = instr
  let a, %B$0
  let %A$0,a
  let a, %B$1
  let %A$1,a

;s16 = s8  (we must sign extend the byte)
rule let %A:int, %B:sbyte = instr
	let x, 0
	let a, %B
	ifeq _positive, n, 0
	sub x, x, 1
	label _positive
	let %A$0, a
	let %A$1, x
		
;======= Address of array

rule let %A:byte1, %B:adr(%C:byte) = instr
	let y, %C
	let a, @%B$y
	let %A, a

rule let %B:adr(%C:byte), %A:byte1 = instr
	let a, %A
	let y, %C
	let @%B$y, a

rule let_adr %A:adr, %B:adr(const %C) = instr
	lo  %Z, %C
	let a, %B$0
	let c, 0
	add as, ac, %Z
	let %A$0, a
	hi  %Z, %C
	let a, %B$1
	add as, ac, %Z
	let %A$1, a

rule let_adr %A:adr, %B:adr(%C:byte) = instr
	let a, %B$0
	let c, 0
	add as, ac, %C
	let %A$0, a
	let a, %B$1
	add as, ac, 0
	let %A$1, a

  
;======== Array (byte index, byte value)
;We use indexing using X register.
;Optimizer may later change it to Y.

rule let %A:byte1arr(const %B:byte),%C:byte  = instr
	let a,%C
	mul %Z, %B, %A.step
	let %A$%Z,a    ;with constant, we do not need to load index register X

;Access to low or high byte of card
rule let %A:byte2(const %B:byte), %C:byte = instr
  let a,%C
  let %A$%B,a    ;with constant, we do not need to load index register X
  
;Prevent compiler from generation extra code, when we are already assigning a register.

rule let a,%A:byte1arr(%B:byte) = instr
	let a, %B
	mul a, a, %A.step
	let x,a
	let a,%A$x

rule let %A:byte1arr(%B:byte), a = instr
	let y, a 
	let a, %B
	mul a, a, %A.step
	let x,a 
	let a, y
	let %A$x,a

rule let %A:byte1arr(%B:byte),%C:byte1 = instr
	let a, %B
	mul a, a, %A.step
	let x,a
	let a,%C
	let %A$x,a

;Accessing one dimensional array using constant is optimized to direct access.
rule let %A:byte1,%B:byte1arr(const %C) = instr
	let a,%B$%C
	let %A, a
	
rule let %A:byte1,%B:byte1arr(%C:byte) = instr 
	let a, %C
	mul a, a, %B.step
	let x, a
	let a,%B$x
	let %A, a

;rule let %A:byte1arr(%B:byte),%C:byte1arr(%D:byte) = instr 
;	let a,%C(%D)
;	let %A(%B), a

rule let_adr %A:adr, %B:byte1arr(%D:byte) = instr
	lo a, %B(%D)
	let %A$0, a
	hi a, %B(%D)
	let %A$1, a
 
;======= Array of array (is simmilar to 2D array, but x & y are not switched)

type arr_of_arr:array(byte) of array(byte) of byte1

;rule alloc %A:array(byte) of array(byte) of byte1, %B, %C = "   .ds %B*%C"
;rule arrindex %A:array(byte) of array(byte) of byte1,%B,%C    = "%A_lo:  :%B dta l(%A + #*%C)" "%A_hi:  :%B dta h(%A + #*%C)"

rule alloc %A:array(byte) of array(byte) of byte1, %B, %C = "   .ds %B*%C"
rule arrindex %A:array(byte) of array(byte) of byte1,%B,%C    = "%A_lo:  :%B dta l(%A + #*%C)" "%A_hi:  :%B dta h(%A + #*%C)"

rule let %A:arr_of_arr(%B:byte)(%C:byte), %D:byte1 = instr
	let y, %B
	lo a, %A$y			;this accesses lower byte of array of pointers
	let _arr$0, a
	hi a, %A$y
	let _arr$1, a
	let y, %C
	let a, %D
	let @_arr$y, a	

rule let_adr %D:adr, %A:arr_of_arr(%B:byte)(%C:byte) = instr
	let y, %C
	lo a, %A$y
	let c, 0
	add as, ac, %B
	let %D$0, a
	hi a, %A$y
	add as, ac, 0	
	let %D$1, a

;======= 2D byte array
	
;2D Array (2x byte index, byte value)
;We use indexing using Y register.

rule let %A:_byte1arr2D(%B:byte, %C:byte), %D:byte = instr
	let y, %C
	lo a, %A$y			;this accesses lower byte of array of pointers
	let _arr$0, a
	hi a, %A$y
	let _arr$1, a
	let y, %B
	let a, %D
	let @_arr$y, a	

rule let %D:byte, %A:_byte1arr2D(%B:byte, %C:byte)  = instr
	let y, %C
	lo a, %A$y
	let _arr$0, a
	hi a, %A$y
	let _arr$1, a
	let y, %B
	let a, @_arr$y	
	let %D, a

rule let_adr %D:adr, %A:_byte1arr2D(%B:byte,%C:byte) = instr
	let y, %C
	lo a, %A$y
	let c, 0
	add as, ac, %B
	let %D$0, a
	hi a, %A$y
	add as, ac, 0	
	let %D$1, a

;===========

;Convert 2-byte const to 1-byte
rule let %A:byte, const %B:card = instr
	lo a, %B
	let %A, a

rule let %A:card,const %B:card = instr
  lo  %Z, %B
  let a, %Z
  let %A$0,a
  hi  %Z, %B
  let a, %Z
  let %A$1,a

;int <- byte,  card <- byte
rule let %A:byte2, %B:byte = instr
	let a,%B
	let %A$0, a
	let a, 0
	let %A$1, a

;Convert 2-byte variable to 1-byte
;TODO: This is LO !!!!!
rule let %A:byte, %B:card = instr
	let a, %B$0
	let %A, a

;TODO: We should add adr to byte2, this would remove the necessity for 3 of following 4 rules
rule let %A:byte2,%B:byte2   = instr
  let a,%B$0
  let %A$0,a
  let a,%B$1
  let %A$1,a

rule let %A:adr, %B:adr = instr
  let a, %B$0
  let %A$0, a
  let a, %B$1
  let %A$1, a

rule let %A:adr, %B = instr
  lo a, %B
  let %A$0, a
  hi a, %B
  let %A$1, a

rule let %A:card, %B:adr = instr
  let a, %B$0
  let %A$0, a
  let a, %B$1
  let %A$1, a


rule let %A:card, a = instr
	let %A$0, a
	let %A$1, 0

;---- Tuples

rule let (%A:byte1, %B:byte1), const %C:byte2a  = instr
	lo %A, %C
	hi %B, %C

rule let %A:byte2, (%B:byte1, %C:byte1) = instr
	let %A$0, %B
	let %A$1, %C
	
rule let (%A:byte1, %B:byte1), %C:byte2a  = instr
	let %A, %C$0
	let %B, %C$1

rule let (%A:byte1, %B:byte1), (%C:byte1, %D:byte1)  = instr
	let %A, %C
	let %B, %D

rule let_adr (%A:byte1, %B:byte1), %D = instr
  let_adr %A, %D$0
  let_adr %B, %D$1
 
;Extracting lower/higher part of tuple

rule lo a, (%A:byte1, %B) = instr let a, %A
rule hi a, (%A, %B:byte1) = instr let a, %B

;===== Long
rule let %A:long,const %B:long = instr
  lo %Z, %B
  let a,%Z
  let %A$0,a
  hi %Z, %B 
  let a,%Z 
  let %A$1,a
  div %Z,%B,$FFFF   ; highest byte
	and %Z, %Z, $FF  
  let a,%Z
  let %A$2,a

;===== Byte array with 2 byte index

rule let %C:byte1arr(%D:card), %A:byte = instr
  let_adr a, %C$0
  let _arr$0, a
  let_adr a, %C$1
  let c, 0
  add as, ac,  %D$1
  let _arr$1, a
  let y,%D$0
  let a,%A
  let @_arr$y, a  

rule let %C:byte1arr(%D:card), a = instr
  let x,a
  let_adr a, %C$0
  let _arr$0, a
  let_adr a, %C$1
  let c, 0
  add as, ac,  %D$1
  let _arr$1, a
  let y,%D$0
  let a,x
  let @_arr$y, a  

rule let %A:byte, %C:byte1arr(%D:card)  = instr
  let_adr a, %C$0
  let _arr$0, a
  let_adr a, %C$1
  let c, 0
  add as, ac,  %D$1
  let _arr$1, a
  let y,%D$0
  let a, @_arr$y  
  let %A,a

;******** Let_adr
	
;Compute address of specified element in array and store it to specified variable

rule let_adr %A:adr, %B = instr
  let_adr a, %B$0
  let %A$0, a
  let_adr a, %B$1
  let %A$1, a

;Special versions of let adr, that provide for upper and lower part of an address
;Second argument defines the byte.
;This instructions are generated by other rules on upper levels.

rule let_adr a, %A$0 = "   lda #<%A" 
rule let_adr a, %A$1 = "   lda #>%A" 

rule let_adr x, %A$0 = "   ldx #<%A" 
rule let_adr x, %A$1 = "   ldx #>%A" 

rule let_adr y, %A$0 = "   ldy #<%A" 
rule let_adr y, %A$1 = "   ldy #>%A" 

;*********** Lo

rule lo %A, %B = instr
  lo a, %B  
  let %A, a

rule lo a, %A:byte2 = instr
	let a, %A$0
	  
rule lo a, %A$y = "   lda %A_lo,y"
rule lo a,const %A     = "   lda #<%A"
rule lo x,const %A     = "   ldx #<%A"
rule lo y,const %A     = "   ldy #<%A"

rule lo a,%A:byte1 = "   lda %A"
rule lo x, %A     =  "   ldx %A"
rule lo y, %A     =  "   ldy %A"

;These rules return hi and lo byte of an one byte array element
rule lo a, %A:byte1arr(const %B) = "   lda #<(%A-%A.index.min+%B)"
rule hi a, %A:byte1arr(const %B) = "   lda #>(%A-%A.index.min+%B)"

rule lo x, %A:byte1arr(const %B) = "   ldx #<(%A-%A.index.min+%B)"
rule hi x, %A:byte1arr(const %B) = "   ldx #>(%A-%A.index.min+%B)"

rule lo y, %A:byte1arr(const %B) = "   ldy #<(%A-%A.index.min+%B)"
rule hi y, %A:byte1arr(const %B) = "   ldy #>(%A-%A.index.min+%B)"


;*********** Hi

rule hi %A, %B = instr
  hi a, %B
  let %A, a

rule hi a, %A$y      = "   lda %A_hi,y"
rule hi a, %A:arr_of_arr = "   lda #>%A"
rule hi a, const %A    = "   lda #>%A"
rule hi a,%A:card      = "   lda %A+1"
rule hi x, %A     =  "   ldx %A+1"
rule hi y, %A     =  "   ldy %A+1"

;*********** Add

rule add %A:byte1, %B:byte1, 1 = instr
	let a, %B
	let %A, a
	add %A, %A, 1

;u8 = u8 + u8
;s8 = s8 + s8
;s8 = u8 + s8
rule add %A:byte1, %B:byte1, %C:byte1 = instr
  let a,%B 
  let c,0
  add as, ac, %C
  let %A,a
  
rule add %A:byte, %B:card, %C:byte = instr
  let a,%B$0
  let c,0
  add as, ac, %C
  let %A,a
  
rule add as, ac, %A:byte1arr(%B:byte) = instr
	let x,%B
	add as, ac, %A$x

rule add %A:byte1arr(%B:byte),%C:byte1arr(%D:byte),%E:byte1arr(%F:byte) = instr
	let a,%C(%D)
	let c,0
	add as, ac, %E(%F)
	let %A(%B), a

rule add %A:byte1arr(%B:byte),%C:byte,%D:byte = instr
	let a,%C
	let c,0
	add as, ac, %D
	let x,%B
	let %A$x,a

rule add %A:byte,%B:byte1arr(%C:byte),%D:byte = instr
	let x,%C
	let a,%B$x
	let c,0
	add as, ac, %D
	let %A, a

;u16 = u8 + u8
rule add %A:card,%B:byte,%C:byte = instr
	let a, %B
	let c, 0
	add as, ac, %C
	let %A$0,a
	let a, 0
	rol a,a,1			; rol
	let %A$1, a	
	
;s16 = s8 + s8
rule add %A:int,%B:sbyte,%C:sbyte = instr
	let x, 0
	let a, %B
	let c, 0
	add as, ac, %C
	ifeq _no_overflow, v, 0			;if there was overfow, switch the negative bit
	ifeq _negative, n, 0
	ifeq _positive, n, 1		
	label _no_overflow
	ifeq _positive, n, 0	
	label _negative
	sub x, x, 1	
	label _positive
	let %A$0,a
	let %A$1,x	

;s16 = s16 + s8
;s16 = u16 + s8
;u16 = u16 + s8
rule add %R:byte2, %A:byte2, %B:sbyte = instr
  let x, 0
  let a, %B
  ifeq positive, n, 0
  sub x, x, 1
  label positive
  let c, 0
  add as, ac, %A$0
	let %R$0, a
	let a, x
	add as, ac, %A$1
	let %R$1, a

;u16 += 1
rule add %A:card,%A:card,1 = instr
  add %A$0, %A$0, 1
  ifeq _lab1, z, 0
  add %A$1, %A$1, 1
  label _lab1

;u16 += u8
rule add %A:card,%A:card,%B:byte = instr
	let a, %A$0
	let c, 0
	add as, ac, %B
	let %A$0,a
	ifeq _skip1,c,0
	add %A$1,%A$1,1
	label _skip1

;u16 = u16 + u8
;s16 = s16 + u8
rule add %A:byte2,%B:byte2,%C:byte = instr
	let a, %B$0
	let c, 0
	add as, ac, %C
	let %A$0,a
	let a, %B$1
	add as, ac, 0
	let %A$1, a

rule add %A:card, %B:byte, const %C:card = instr
	let a, %B
	lo %Z, %C           ; %Z is macro local variable
	let c, 0
	add as, ac, %Z
	let %A$0, a
	let a, 0
	hi %Z, %C           ; %Z is macro local variable
	add as, ac, %Z
	let %A$1, a

rule add %A:card, %B:card, const %C:card = instr
	let a, %B$0
	lo %Z, %C           ; %Z is macro local variable
	let c, 0
	add as, ac, %Z
	let %A$0, a
	let a, %B$1
	hi %Z, %C           ; %Z is macro local variable
	add as, ac, %Z
	let %A$1, a

;u16 = u16 + u16
rule add %A:card, %B:card, %C:card = instr
	let a, %B$0
	let c, 0
	add as, ac, %C$0
	let %A$0, a
	let a, %B$1
	add as, ac, %C$1
	let %A$1, a

;Signed addition
rule add %A:int, %B:int, %C:int = instr
	let a, %B$0
	let c, 0
	add as, ac, %C$0
	let %A$0, a
	let a, %B$1
	add as, ac, %C$1
	let %A$1, a

;TODO: Remove
rule add %A:int, %B:int, const %C:int = instr
	let a, %B$0
	lo %Z, %C           ; %Z is macro local variable
	let c, 0
	add as, ac, %Z
	let %A$0, a
	let a, %B$1
	hi %Z, %C           ; %Z is macro local variable
	add as, ac, %Z
	let %A$1, a

;3-byte Increment
rule add %A:long,%A:long,1 = instr
  add %A$0, %A$0, 1
  ifeq _lab2, z, 0
  add %A$1, %A$1, 1
  ifeq _lab2, z, 0
  add %A$2, %A$2, 1
  label _lab2
  
rule add x,x,1 = "   inx"
rule add y,y,1 = "   iny"
rule add as, ac, %A$const %B = "   adc %A+%B"
rule add %A$const %B, %A$%B, 1 = "   inc %A+%B"
rule add as, ac, const %A:byte1  = "   adc #%A"
rule add as, ac,%A:byte1 = "   adc %A"
rule add as, ac, %A$x =  "   adc %A,x"
rule add as, ac, %A$y =  "   adc %A,y"

rule add %A:byte1,%A,1 = "   inc %A"

;*********** Sub

rule sub %A:byte1, %B:byte1, 1 = instr
	let a, %B
	let %A, a
	sub %A, %A, 1

rule sub %A:byte1, %B:byte1, %C:byte1 = instr
  let a,%B
  let c,1
  sub a,a,%C
  let %A,a

rule sub %A:card, %B:card, const %C:card = instr
	let a, %B$0
	lo %Z, %C           ; %Z is macro local variable
	let c, 1
	sub a, a, %Z
	let %A$0, a
	let a, %B$1
	hi %Z, %C           ; %Z is macro local variable
	sub a, a, %Z
	let %A$1, a

rule sub %A:card, const %B:card, %C:card = instr
	lo a, %B
	let c, 1
	sub a, a, %C$0
	let %A$0, a
	hi a, %B
	sub a, a, %C$1
	let %A$1, a

rule sub %A:card, %B:card, %C:card = instr
	let a, %B$0
	let c, 1
	sub a, a, %C$0
	let %A$0, a
	let a, %B$1
	sub a, a, %C$1
	let %A$1, a
	

;*********** Multiplication

; helper in multiplying by 3; leaves result in a
rule mula %A:byte, 2    = instr
	let a, %A			; lda %B
	mul a, a, 2   ; asl

rule mula %A:byte, 3    = instr
	let a, %A			; lda %B
	mul a, a, 2   ; asl
	let c, 0
	add as, ac, %A

rule mula %A:byte, 5    = instr
	let a, %A			; lda %B
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	let c, 0
	add as, ac, %A

rule mul %A:byte, %A:byte, 3	= instr
	mula %A, 3
	let %A, a

rule mul %A:byte, %B:byte, 0    = instr
	let a, 0			; lda %B
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 1    = instr
	let a, %B			; lda %B
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 2    = instr
	let a, %B			; lda %B
	mul a, a, 2   ; asl
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 3    = instr
	mula %B, 3
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 4    = instr
	let a, %B			; lda %B
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 5    = instr
	mula %B, 5
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 6    = instr
	mula %B, 3
	mul a, a, 2
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 8    = instr
	let a, %B			; lda %B
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 10    = instr
	mula %B, 5
	mul a, a, 2
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 12    = instr
	mula %B, 3
	mul a, a, 2
	mul a, a, 2
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 16    = instr
	let a, %B			; lda %B
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 20    = instr
	mula %B, 5
	mul a, a, 2
	mul a, a, 2
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 24    = instr
	mula %B, 3
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 32    = instr
	let a, %B			; lda %B
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 40    = instr
	mula %B, 5
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 48    = instr
	mula %B, 3
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 64    = instr
	let a, %B			; lda %B
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	mul a, a, 2   ; asl
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 80    = instr
	mula %B, 5
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 96    = instr
	mula %B, 3
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 128    = instr
	let a, %B			; lda %B
	div a, a, 2
	let a, 0
	ror a, a, 1
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 160    = instr
	mula %B, 5
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	let %A, a      ; sta %A

rule mul %A:byte, %B:byte, 192    = instr
	mula %B, 3
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	let %A, a      ; sta %A

;rule mul %A:card, %B:byte, 0    = instr
;	let a, 0	; lda #0
;	let %A$0, a   ; sta %A
;	let %A$1, a   ; sta %A+1

rule mul %A:card, %B:byte, 1    = instr
	let a, %B			; lda %B
	let %A$0, a   ; sta %A
	let a, 0	; lda #0
	let %A$1, a   ; sta %A+1

rule mul %A:card, %B:byte, 2    = instr
	let a, %B			; lda %B
	mul a, a, 2   ; asl
	let %A$0, a   ; sta %A
	let a, 0	; lda #0
	rol a,a,1			; rol
	let %A$1, a   ; sta %A+1

; if no "=instr" segfaults
rule mula16 %A:card, %B:byte, 2	= instr
	let a, %B
	mul a, a, 2
	let %A$0, a
	let a, 0
	rol a, a, 1

;rule mula16 %B:card, %A:card, 2	= instr
;	let a, %A$0
;	mul a, a, 2
;	let _TEMPW1$0, a
;	let a, %A$1
;	rol a, a, 1

rule mula16 %A:card, %B:byte, 4	= instr
	mula16 %A, %B, 2
	mul %A$0, %A$0, 2
	rol a, a, 1

rule mula16 %A:card, %B:byte,  8	= instr
	mula16 %A, %B, 4
	mul %A$0, %A$0, 2
	rol a, a, 1

rule mula16 %A:card, %B:byte,  16	= instr
	mula16 %A, %B,8
	mul %A$0, %A$0, 2
	rol a, a, 1

rule mula16 %A:card, %B:byte,  32	= instr
	mula16 %A, %B, 16
	mul %A$0, %A$0, 2
	rol a, a, 1

rule mula16 %A:card, %B:byte,  64	= instr
	mula16 %A, %B, 32
	mul %A$0, %A$0, 2
	rol a, a, 1

rule mula16 %A:card, %B:byte,  128	= instr
	mula16 %A, %B, 64
	mul %A$0, %A$0, 2
	rol a, a, 1

rule mul %A:card, %B:byte, 4    = instr
	mula16 %A, %B, 4
	let %A$1, a

rule mul %A:card, %B:byte, 8    = instr
	mula16 %A, %B, 8
	let %A$1, a

rule mul %A:card,%B:byte, 16    = instr
	mula16 %A, %B, 16
	let %A$1, a

rule mul %A:card,%B:byte, 32    = instr
	let a, %B
	div a, a, 2
	let %A$1, a
	let a, 0
	ror a, a, 1
	div %A$1, %A$1, 2
	ror a, a, 1
	div %A$1, %A$1, 2
	ror a, a, 1
	let %A$0, a

rule mul %A:card,%B:byte, 64    = instr
	let a, %B
	div a, a, 2
	let %A$1, a
	let a, 0
	ror a, a, 1
	div %A$1, %A$1, 2
	ror a, a, 1
	let %A$0, a

; more efficient would be from the other side
rule mul %A:card,%B:byte, 128    = instr
	let a, %B
	div a, a, 2
	let %A$1, a
	let a, 0
	ror a, a, 1
	let %A$0, a

rule mul %A:card,%B:byte, 256    = instr
	let a, %B
	let %A$1, a
	let a, 0
	let %A$0, a

rule mul %A:card,%B:byte, 512    = instr
	mula %B, 2
	let %A$1, a
	let a, 0
	let %A$0, a

rule mul %A:card,%B:byte, 1024    = instr
	mula %B, 2
	mul a, a, 2
	let %A$1, a
	let a, 0
	let %A$0, a

rule mul %A:card,%B:byte, 2048    = instr
	mula %B, 2
	mul a, a, 2
	mul a, a, 2
	let %A$1, a
	let a, 0
	let %A$0, a


rule mul %A:card,%B:byte, 4096    = instr
	mula %B, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	let %A$1, a
	let a, 0
	let %A$0, a



rule mul %A:card,%B:byte, 8192    = instr
	mula %B, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	let %A$1, a
	let a, 0
	let %A$0, a


rule mul %A:card,%B:byte, 16384    = instr
	mula %B, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	mul a, a, 2
	let %A$1, a
	let a, 0
	let %A$0, a

; This optimizes wrong way
;rule mul %A:card,%B:byte, 32768    = instr
;	let a, %B			; lda %B
;	div a, a, 2
;	let a, 0
;	ror a, a, 1
;	let %A$1, a      ; sta %A
;	let a, 0
;	let %A$0, a

rule mul %A:card,%B:byte, 32768    = instr
	let a, %B			; lda %B
	divc a, a, 2			; do not remove by optimizer
	ror a, a, 1
	and a, a, 128
	let %A$1, a      ; sta %A
	let a, 0
	let %A$0, a

_sys_mul8:proc m1@cpu.a m2@cpu.x >r@_TEMPW2
_sys_mulsu8:proc m1@cpu.a m2@cpu.x @cpu.x @cpu.a >r@_TEMPW2
_sys_mulss8:proc m1@cpu.a m2@cpu.x @cpu.x @cpu.a >r@_TEMPW2

;System routine for multiplication.

rule mul %A:card, %B:byte, %C:byte = instr
	let a, %B			;TODO: let _sys_mul8.m1, %B
	let x, %C
	call _sys_mul8
	ref a					;mul trashes a and x
	ref x          ;x is in fact 0, but we do not have a way of defining this for now
									;something like ASSERT would be interesting
	let %A, _TEMPW2

rule mul %A:int, %B:sbyte, %C:byte = instr
	let a, %B
	let x, %C
	call _sys_mulsu8
	let %A, _TEMPW2

rule mul %A:int, %B:sbyte, %C:sbyte = instr
	let a, %B
	let x, %C
	call _sys_mulss8
	let %A, _TEMPW2

rule mul %A:int, %B:byte, %C:sbyte = instr
	let a, %C
	let x, %B
	call _sys_mulsu8
	let %A, _TEMPW2

;rule mul %A:int, %B:sbyte, %C:sbyte = instr
;	let a, %B			;TODO: let _sys_mul8.m1, %B
;	let x, %C
;	call _sys_mul8
;	ref a					;mul trashes a and x
;	ref x          ;x is in fact 0, but we do not have a way of defining this for now
									;something like ASSERT would be interesting
;	let %A, _TEMPW2
	
rule mul %A:card, %B:card, 2    = instr
	let a, %B$0		; lda %B
	mul a, a, 2   ; asl
	let %A$0, a   ; sta %A
	let a, 0		; lda #0
	let a, %B$1		; lda %B+1
	rol a, a, 1		; rol
	let %A$1, a   ; sta %A+1

_sys_mul16:proc a@_TEMPW1 b@_TEMPW2 >r@_TEMPL1

rule mul %A:card, %B:card, %C:card = instr
	let _TEMPW1, %B
	let _TEMPW2, %C
	call _sys_mul16
	ref a
	ref x
	let %A, _TEMPL1

;*********** Square root

_sys_sqrt16:proc a@_TEMPW1 >r@a 

rule sqrt %A:card, %B:card = instr
	let _TEMPW1, %B
	call _sys_sqrt16
	ref x
	let %A, a
	
;*********** Division

_sys_div8:proc a@_TEMPW1:card b@cpu.a:byte >res@cpu.a:byte >remainder@cpu.x:byte

rule div %A:byte, %B:byte, 2       = instr
	let a, %B
	div a, a, 2
	let %A, a  

rule div %A:byte, %B:byte, 4       = instr
	let a, %B
	div a, a, 2
	div a, a, 2
	let %A, a  

rule div %A:byte, %B:byte, 8       = instr
	let a, %B
	div a, a, 2
	div a, a, 2
	div a, a, 2
	let %A, a  
	
rule div %A:card, %A:card, 2       = instr
	div %A$1, %A$1, 2
	ror %A$0, %A$0, 1

rule div %A:card, %A:card, 4       = instr
	div %A, %A, 2
	div %A, %A, 2
	
rule div %A:card, %A:card, 8       = instr
	div %A, %A, 4
	div %A, %A, 2

rule div %A:card, %B:card, 8       = instr
	let a, %B$0
	let %A$0, a
	let a, %B$1
	div a, a, 2
	ror %A$0, %A$0, 1
	div a, a, 2
	ror %A$0, %A$0, 1
	div a, a, 2
	ror %A$0, %A$0, 1
	let %A$1, a
	
rule div %A:byte, %B:card, %C:byte = instr
	let _TEMPW1, %B			;divident
	let a, %C          ;divisor
	call _sys_div8
	let %A, a

rule div %A:byte1arr(%B:card), %C:card, %D:byte = instr
	let _TEMPW1, %C			;divident
	let a, %D          ;divisor
	call _sys_div8
	let %A(%B), a

;*********** Modulo

rule mod %A, %B:byte, 2 = instr
	let a, %B
	and a, a, 1
	let %A, a

rule mod %A, %B:byte, 4 = instr
	let a, %B
	and a, a, 3
	let %A, a

rule mod %A, %B:byte, 8 = instr
	let a, %B
	and a, a, 7
	let %A, a

rule mod %A, %B:byte, 16 = instr
	let a, %B
	and a, a, 15
	let %A, a

rule mod %A, %B:byte, 32 = instr
	let a, %B
	and a, a, 31
	let %A, a

rule mod %A, %B:byte, 64 = instr
	let a, %B
	and a, a, 63
	let %A, a

rule mod %A, %B:byte, 128 = instr
	let a, %B
	and a, a, 127
	let %A, a

rule mod %A:byte, %B:card, 8 = instr
	let a, %B$0
	and a, a, 7
	let %A, a
		
rule mod %A:byte, %B:card, %C:byte = instr
	let _TEMPW1, %B			;divident
	let a, %C          ;divisor
	call _sys_div8
	let %A, x


;*********** And

rule and a,a,const %A:byte  = "   and #%A"
rule and a,a,%A:byte        = "   and %A"
rule and a,a,%A$x      = "   and %A,x"
rule and a,a,%A$y      = "   and %A,y"
rule and a,a,@%A$y     = "   and (%A),y"

rule and %A:byte,%B:byte,%C:byte = instr
	let a,%B
	and a,a,%C
	let %A,a

rule and %A:byte,%B:card,%C:byte = instr
	let a,%B$0
	and a,a,%C
	let %A,a

rule and %A:byte1arr(%B:byte),%C:byte,%D:byte = instr
	let a,%C
	and a, a, %D
	let x,%B
	let %A$x,a

rule and %A:byte,%B:byte1arr(%C:byte),%D:byte = instr
	let x,%C
	let a,%B$x
	and a, a, %D
	let %A, a

rule and %A:card, %B:card, const %C = instr
	let a, %B$0
	lo   %Z, %C
	and  a, a, %Z 
 	let %A$0, a
 	
	let a, %B$1
	hi   %Z, %C
	and  a, a, %Z 
 	let %A$1, a
 	
rule and %A:card, %B:card, %C:byte = instr
	let a, %B$0
	and  a, a, %C
	let %A$0, a 
	let a, 0
	let %A$1, a
	
rule and %A:card, %B:byte, %C:card = instr and %A, %C, %B

rule and %A:card, %B:card, %C:card = instr
	let a, %B$0
	and   a, a, %C$0
	let %A$0, a
	 
	let a, %B$1
	and   a, a, %C$1
	let %A$1, a

	
;*********** Or

rule or a,a,const %A:byte  = "   ora #%A"
rule or a,a,%A:byte        = "   ora %A"
rule or a,a,%A$x      = "   ora %A,x"
rule or a,a,%A$y      = "   ora %A,y"
rule or a,a,@%A$y     = "   ora (%A),y"

rule or  %A:byte,%B:byte,%C:byte = instr
  let a,%B
  or a,a,%C
  let %A,a

rule or %A:byte1arr(%B:byte),%C:byte,%D:byte = instr
	let a,%C
	or a, a, %D
	let x,%B
	let %A$x,a

rule or %A:byte,%B:byte1arr(%C:byte),%D:byte = instr
	let x,%C
	let a,%B$x
	or a, a, %D
	let %A, a

rule or %A:card, %B:card, const %C = instr
	let a, %B$0
	lo   %Z, %C
	or  a, a, %Z 
 	let %A$0, a
 	
	let a, %B$1
	hi   %Z, %C
	or  a, a, %Z 
 	let %A$1, a
 	
rule or %A:card, %B:card, %C:byte = instr
	let a, %B$0
	or  a, a, %C
	let %A$0, a 
	let a, %B$1
	let %A$1, a
	
rule or %A:card, %B:byte, %C:card = instr or %A, %C, %B

rule or %A:card, %B:card, %C:card = instr
	let a, %B$0
	or   a, a, %C$0
	let %A$0, a
	 
	let a, %B$1
	or   a, a, %C$1
	let %A$1, a

	
;*********** Xor

rule xor azn,a,const %A:byte  = "   eor #%A"
rule xor azn,a,%A:byte        = "   eor %A"
rule xor azn,a,%A$x      = "   eor %A,x"
rule xor azn,a,%A$y      = "   eor %A,y"
rule xor azn,a,@%A$y     = "   eor (%A),y"

rule xor  %A:byte,%B:byte,%C:byte = instr
	let a,%B
	xor azn,a,%C
	let %A,a

rule xor %A:byte1arr(%B:byte),%C:byte,%D:byte = instr
	let a,%C
	xor azn, a, %D
	let x,%B
	let %A$x,a

rule xor %A:byte,%B:byte1arr(%C:byte),%D:byte = instr
	let x,%C
	let a,%B$x
	xor azn, a, %D
	let %A, a

rule xor %A:card, %B:card, const %C = instr
	let a, %B$0
	lo   %Z, %C
	xor  azn, a, %Z 
 	let %A$0, a
 	
	let a, %B$1
	hi   %Z, %C
	xor  azn, a, %Z 
 	let %A$1, a
 	
rule xor %A:card, %B:card, %C:byte = instr
	let a, %B$0
	xor  azn, a, %C
	let %A$0, a 
	let a, %B$1
	let %A$1, a
	
rule xor %A:card, %B:byte, %C:card = instr xor %A, %C, %B

rule xor %A:card, %B:card, %C:card = instr
	let a, %B$0
	xor   azn, a, %C$0
	let %A$0, a
	 
	let a, %B$1
	xor   azn, a, %C$1
	let %A$1, a
;*********** Not

rule not a,a  = "   eor #$FF"

rule not %A:byte, %B:byte = instr
	let a, %B
	not a,a
	let %A, a	
	
;************ Conditional jumps

rule ifoverflow %A = "   jcs %A"
rule ifnoverflow %A = "   jcc %A"

;if u8 == u8
rule ifeq %L,%B:byte,%C:byte   = instr
  let a, %B          ; lda %A
  sub cznv, a, %C    ; cmp %C
  ifeq %L, z, 1      ; jeq %A

;if s8 == s8
rule ifeq %L,%B:sbyte,%C:sbyte   = instr
  let a, %B          ; lda %A
  sub cznv, a, %C    ; cmp %C
  ifeq %L, z, 1      ; jeq %A

;if s8 = u8
rule ifeq %L,%B:sbyte,%C:byte   = instr
  let a, %B
  ifeq _loc, n, 1
	sub cznv, a, %C
  ifeq %L, z, 1 	 
  label _loc
  
;if u8 = s8
rule ifeq %L,%B:byte,%C:sbyte   = instr
  let a, %C
  ifeq _loc, n, 1
	sub cznv, a, %B
  ifeq %L, z, 1 	 
  label _loc

;shortcut for A register
rule ifne %A,a,%C:byte1   = instr
  sub cznv, a, %C   ; cmp %C
  ifne %A, z, 1      ; jne %A

;if u8 <> u8
rule ifne %L,%A:byte,%B:byte   = instr
  let a, %A          ; lda %L
  sub cznv, a, %B   ; cmp %B
  ifne %L, z, 1      ; jne %L

;if s8 <> s8
rule ifne %L,%A:sbyte,%B:sbyte   = instr
  let a, %A          ; lda %L
  sub cznv, a, %B   ; cmp %B
  ifne %L, z, 1      ; jne %L

;if s8 <> u8
rule ifne %L,%A:sbyte,%B:byte   = instr
  let a, %A
  ifeq %L, n, 1
	sub cznv, a, %B
  ifne %L, z, 1 	 
  
;if u8 <> s8
rule ifne %L,%A:byte,%B:sbyte   = instr
  let a, %B
  ifeq %L, n, 1
	sub cznv, a, %A
  ifne %L, z, 1

;u8 <= u8
rule ifle %L,%A:byte,%B:byte   = instr
  let a, %B          ; lda %A
  sub cznv, a, %A   ; cmp %B
  ifeq %L, c, 1      ; jeq %L

;u8 <= s8
rule ifle %L,%A:byte,%B:sbyte   = instr
  let a, %B          ; lda %A
  ifeq higher, n, 1  ; bmi higher
  sub cznv, a, %A   ; cmp %B
  ifeq %L, c, 1      ; jeq %L
  label higher

;s8 <= s8  -- note the switched order of operands
rule ifle %L,%A:sbyte,%B:sbyte   = instr
  let a, %B          ; lda %A
	let c, 1           ; clc
  sub as, ac, %A    ; sub %B
  ifeq ok, v, 0			; bvc ok
  xor azn, a, 255
  label ok
  ifeq %L, n, 0      ; bpl %L

;u8 >= u8
rule ifge %L,%A:byte,%B:byte   = instr
  let a, %A          ; lda %A
  sub cznv, a, %B   ; cmp %B
  ifeq %L, c, 1      ; jcc %L

;s8 >= u8
rule ifge %L,%A:sbyte,%B:byte   = instr
  let a, %A          ; lda %A
  ifeq lower, n, 1		; bmi lower
  sub cznv, a, %B   ; cmp %B
  ifeq %L, c, 1      ; jcc %L
  label lower

;u8 >= s8
rule ifge %L,%A:byte,%B:sbyte   = instr
  let a, %A          ; lda %A
  ifeq %L, n, 1		  ; bmi lower (positive value >=128)
  sub cznv, a, %B   ; cmp %B
  ifeq %L, c, 1      ; jcc %L
  
;s8 >= s8
rule ifge %L,%A:sbyte,%B:sbyte   = instr
  let a, %A          ; lda %A
	let c, 1           ; clc
  sub as, ac, %B    ; sub %B
  ifeq ok, v, 0			; bvc ok
  xor azn, a, 255
  label ok
  ifeq %L, n, 0      ; bpl %L

;if u8 < u8
rule iflt %L,%A:byte,%B:byte   = instr
  let a, %A          ; lda %A
  sub cznv, a, %B   ; cmp %B
  ifeq %L, c, 0      ; jcs %L

;if s8 < s8
rule iflt %L,%A:sbyte,%B:sbyte   = instr
  let a, %A          ; lda %A
	let c, 1           ; clc
  sub as, ac, %B    ; sub %B
  ifeq ok, v, 0			; bvc ok
  xor azn, a, 255
  label ok
  ifeq %L, n, 1      ; bmi %L

;if u8 < s8
rule iflt %L,%A:byte,%B:sbyte   = instr
  let a, %A          ; lda %A
  ifeq higher, n, 1   ; bmi higher
  sub cznv, a, %B   ; cmp %B
  ifeq %L, c, 0      ; jcs %L
  label higher
  
;if s8 < u8
rule iflt %L,%A:sbyte,%B:byte   = instr
  let a, %A          ; lda %A
  ifeq %L, n, 1      ; bmi %L
  sub cznv, a, %B   ; cmp %B
  ifeq %L, c, 0      ; jcs %L

;if u8 > s8  -- note the switched order of operands
rule ifgt %L,%A:byte,%B:sbyte   = instr
  let a, %B          ; lda %A
  ifeq %L, n, 1
  sub cznv, a, %A   ; cmp %B
  ifeq %L, c, 0      ; jcs %L

;if s8 > u8  -- note the switched order of operands
rule ifgt %L,%A:sbyte,%B:byte   = instr
  let a, %B          ; lda %A
  ifeq %L, n, 1			; unsigned >= 128 
  sub cznv, a, %A   ; cmp %B
  ifeq %L, c, 0      ; jcs %L
  
;if u8 > u8  -- note the switched order of operands
rule ifgt %L,%A:byte,%B:byte   = instr
  let a, %B          ; lda %A
  sub cznv, a, %A   ; cmp %B
  ifeq %L, c, 0      ; jcs %L

;if s8 > s8  -- note the switched order of operands
rule ifgt %L,%A:sbyte,%B:sbyte   = instr
  let a, %B          ; lda %A
	let c, 1           ; clc
  sub as, ac, %A    ; sub %B
  ifeq ok, v, 0			; bvc ok
  xor azn, a, 255
  label ok
  ifeq %L, n, 1      ; bmi %L

;16-bit comparisons

;if s16 = u16
rule ifeq %L,%B:int,%C:card  = instr
	let a, %B$1
	ifeq diff, n, 1
	sub cznv, a, %C$1
	ifeq diff, z, 0
	let a, %B$0
	sub cznv, a, %C$0	 
	ifeq %L, z, 1	
	label diff	

;if u16 = s16
rule ifeq %L,%B:card,%C:int  = instr
	let a, %C$1
	ifeq diff, n, 1
	sub cznv, a, %B$1
	ifeq diff, z, 0
	let a, %C$0
	sub cznv, a, %B$0	 
	ifeq %L, z, 1	
	label diff	

;if u16 = u16 
;if s16 = s16
rule ifeq %L,%B:byte2,%C:byte2  = instr
	let a, %B$1
	sub cznv, a, %C$1
	ifne _loc, z, 1
	let a, %B$0
	sub cznv, a, %C$0
	ifeq %L, z, 1
	label _loc

;if s16 <> u16
rule ifne %L,%B:int, %C:card = instr
  let a, %B$1
  ifeq %L, n, 1
  sub cznv, a, %C$1
  ifne %L, z, 1
  let a, %B$0
  sub cznv, a, %C$0
  ifne %L, z, 1

;if u16 <> s16
rule ifne %L,%B:card, %C:int = instr
  ifne %L, %C, %B

;if u16 <> u16
;if s16 <> s16
rule ifne %L,%B:byte2, %C:byte2 = instr
  let a, %B$1
  sub cznv, a, %C$1
  ifne %L, z, 1
  let a, %B$0
  sub cznv, a, %C$0
  ifne %L, z, 1

;if u16 < u16
rule iflt %L,%B:card, %C:card   = instr
  let a, %B$1          ; lda %B
  sub cznv, a, %C$1    ; cmp %C
  ifeq %L, c, 0				 ; bcc %L
  ifeq lab, z, 0       ; bne lab 
  let a, %B$0          ; lda %B+1
  sub cznv, a, %C$0    ; cmp %C+1
  ifeq %L, c, 0        ; jcs %A
	label lab

;This is support rule for signed 2-byte comparison.
rule sub n, %B:int, %C:int = instr
	let a, %B$0
	sub cznv, a, %C$0
	let a, %B$1
	sub as, ac, %C$1
	ifeq lab, v, 0
	xor azn, a, 255
	label lab
 
;if s16 < s16
rule iflt %L,%B:int, %C:int   = instr
	sub n, %B, %C
	ifeq %L, n, 1

;if s16 < u16
rule iflt %L,%B:int, %C:card   = instr
  let a, %B$1          ; lda %B
  ifeq %L, n, 1				 ; bmi %A  -- integer is negative = is smaller
  sub cznv, a, %C$1    ; cmp %C
  ifeq %L, c, 0				 ; bcc %L
  ifeq lab, z, 0       ; bne lab 
  let a, %B$0          ; lda %B+1
  sub cznv, a, %C$0    ; cmp %C+1
  ifeq %L, c, 0        ; jcs %A
	label lab

;if u16 > u16
rule ifgt %L,%B:card,%C:card  = instr
  let a, %B$1         ; lda %B
  sub cznv, a, %C$1   ; cmp %C
  ifeq _lab1, z, 1    ; beq _lab1
  ifeq %L, c, 1       ; bcs %A
  label _lab1
  let a, %B$0         ; lda %B+1
  sub cznv, a, %C$0   ; cmp %C+1
  ifeq _lab2, z, 1    ; beq _lab2
  ifeq %L, c, 1       ; jcs %A
  label _lab2

;if s16 > s16
rule ifgt %L,%B:int, %C:int   = instr
	sub n, %B, %C
	ifeq %L, n, 0

;if s16 > u16
rule ifgt %L,%B:int, %C:card  = instr
  let a, %B$1         ; lda %B
  ifeq _lab2, n, 1		; bmi _lab2 -- %B is negative and thus lower
  sub cznv, a, %C$1   ; cmp %C
  ifeq _lab1, z, 1    ; beq _lab1
  ifeq %L, c, 1       ; bcs %A
  label _lab1
  let a, %B$0         ; lda %B+1
  sub cznv, a, %C$0   ; cmp %C+1
  ifeq _lab2, z, 1    ; beq _lab2
  ifeq %L, c, 1       ; jcs %A
  label _lab2

;if u16 <= u16
rule ifle %L,%B:card, %C:card   = instr
  let a, %B$1          ; lda %B+1
  sub cznv, a, %C$1    ; cmp %C+1
  ifeq %L, c, 0        ; bcc %L		-- higher byte is lower => %B < %C 
  let a, %B$0          ; lda %B+0 -- higher byte is smaller or equal
  sub cznv, a, %C$0    ; cmp %C+0  
  ifeq %L, c, 0        ; jcs %A   -- lower byte is lower or equal
	ifeq %L, z, 1

;if s16 <= s16
rule ifle %L,%B:int, %C:int   = instr
	ifgt %L, %C, %B

;if s16 <= u16
rule ifle %L,%B:int, %C:card   = instr
  let a, %B$1          ; lda %B+1
  ifeq %L, n, 1
  sub cznv, a, %C$1    ; cmp %C+1
  ifeq %L, c, 0        ; bcc %L		-- higher byte is lower => %B < %C 
  let a, %B$0          ; lda %B+0 -- higher byte is smaller or equal
  sub cznv, a, %C$0    ; cmp %C+0  
  ifeq %L, c, 0        ; jcs %A   -- lower byte is lower or equal
	ifeq %L, z, 1

;if u16 >= u16
rule ifge %L,%B:card, %C:card   = instr
  let a, %B$1          ; lda %B
  sub cznv, a, %C$1    ; cmp %C
  ifeq lab, c, 0				 ; bcc %L
  ifeq %L, z, 0       ; bne lab 
  let a, %B$0          ; lda %B+1
  sub cznv, a, %C$0    ; cmp %C+1
  ifeq %L, c, 1        ; jcs %A
	label lab

;if s16 >= s16
rule ifge %L,%B:int, %C:int   = instr
	iflt %L, %C, %B

;if s16 >= u16
rule ifge %L,%B:int, %C:card   = instr
  let a, %B$1         ; lda %B
  ifeq lab, n, 1			; bmi lab  -- integer is negative = is not greater or equal
  sub cznv, a, %C$1   ; cmp %C
  ifeq lab, c, 0			; bcc %L
  ifeq %L, z, 0       ; bne lab 
  let a, %B$0         ; lda %B+1
  sub cznv, a, %C$0   ; cmp %C+1
  ifeq %L, c, 1       ; jcs %A
	label lab


;==============================	
;Rules emmiting compiled output
;==============================
;
;These rules are used in last step of compilation to transform compiler
;instructions to CPU specific instructions.
;Some rule must match every compiler instruction possible in this stage.
;(Previous compilation stages are responsible to prepare the
; code in such a way, that this is true). 
 
;CLC,SEC

rule let c, 0  = "   clc"
rule let c, 1  = "   sec"

;FLAG-specific conditional jumps

rule ifeq %A, z, 0  = "   jne %A"
rule ifeq %A, z, 1  = "   jeq %A"
rule ifne %A, z, 0  = "   jeq %A"
rule ifne %A, z, 1  = "   jne %A"

rule ifeq %A, c, 0  = "   jcc %A"
rule ifeq %A, c, 1  = "   jcs %A"
rule ifne %A, c, 0  = "   jcs %A"
rule ifne %A, c, 1  = "   jcc %A"

rule ifeq %A, v, 0  = "   jvc %A"
rule ifeq %A, v, 1  = "   jvs %A"
rule ifne %A, v, 0  = "   jvs %A"
rule ifne %A, v, 1  = "   jvc %A"

rule ifeq %A, n, 0  = "   jpl %A"
rule ifeq %A, n, 1  = "   jmi %A"
rule ifne %A, n, 0  = "   jmi %A"
rule ifne %A, n, 1  = "   jpl %A"

;CMP,CPX,CPY
;Compare is implemented as sub, where the result it stored only into
;flag registers and not any other register.

rule sub cznv, a, const %A:byte1 = "   cmp #%A"
rule sub cznv, a, %A$const %B    = "   cmp %A-%A.index.min+%B"
rule sub cznv, a, %A:byte1       = "   cmp %A"

rule sub cznv, x, const %A:byte1 = "   cpx #%A"
rule sub cznv, x, %A$const %B    = "   cpx %A-%A.index.min+%B"
rule sub cznv, x, %A:byte1       = "   cpx %A"

rule sub cznv, y, const %A:byte1 = "   cpy #%A"
rule sub cznv, y, %A$const %B    = "   cpy %A-%A.index.min+%B"
rule sub cznv, y, %A:byte1       = "   cpy %A"

;TAX,TAY,TYA,TXA

rule let x,a      = "   tax"
rule let y,a      = "   tay"
rule let a,x      = "   txa"
rule let a,y      = "   tya"

;LDX

rule let x,const %A:byte1   = "   ldx #%A"
rule let x,%A$const %B = "   ldx %A-%A.index.min+%B"
rule let x,%A$y       = "   ldx %A-%A.index.min,y"
rule let x,%A:byte1        = "   ldx %A"

;LDY
rule let y,const% A:byte1   = "   ldy #%A"
rule let y,%A$const %B = "   ldy %A-%A.index.min+%B"
rule let y,%A$x       = "   ldy %A-%A.index.min,x"
rule let y,%A:byte1        = "   ldy %A"

;LDA

rule let a,%A$%B             = "   lda %A+%B"
rule let a,const %A:byte1    = "   lda #%A"
rule let a,%A:byte1     = "   lda %A"

;rule let a, %A$0  = "   lda %A-%A.index.min"       ;would be handled by next rule but we do not want +0 there
rule let a,%A$const %B  = "   lda %A-%A.index.min+%B"
rule let a, %A$x = "   lda %A-%A.index.min,x"
rule let a, %A$y = "   lda %A-%A.index.min,y"

rule let a, @%A$y  = "   lda (%A),y"


;STA

rule let %A$const %B,a  = "   sta %A-%A.index.min+%B"
rule let %A:byte1,a  = "   sta %A"
rule let @%A$y,a  = "   sta (%A),y"
rule let %A$x,a  = "   sta %A-%A.index.min,x"
rule let %A$y,a  = "   sta %A-%A.index.min,y"

;This is special instruction that 'touches' the specified variable (i.e.
;writes any value into specified variable).
 
rule let %A:byte1, void = "   sta %A"

;STX
rule let %A$const %B,x  = "   stx %A-%A.index.min+%B"
rule let %A:byte1,x  = "   stx %A"

;STY
rule let %A$const %B,y  = "   sty %A-%A.index.min+%B"
rule let %A:byte1,y                     = "   sty %A"

;LSR,ASL
;rule div a,a,1 = "   ;"
rule div a,a,2 = "   lsr"
rule div %A:byte,%A,1 = "   ;"
rule div %A:byte,%A,2 = "   lsr %A"
rule div %A$1,%A$1,2 = "   lsr %A+1"
;TODO: div a(const)
rule divc a,a,2 = "   lsr"

;rule mul a,a,0 = "   lda #0"
;rule mul a,a,1 = "   ;"
rule mul a,a,2 = "   asl"
;rule mul %A:byte,%A:byte,0 = "   lda #0" "   sta %A"
;TODO: Unrecognized error superfluous )!!!
;rule mul %A$const %B),%A$%B,2  = "  asl %A-%A.index.min+%B"
rule mul %A$const %B,%A$%B,2  = "   asl %A-%A.index.min+%B"
rule mul %A(const %B),%A(%B),2  = "   asl %A-%A.index.min+%B"
rule mul %A:byte,%A:byte,1 = "   ;"
rule mul %A:byte,%A:byte,2 = "   asl %A"
rule mul %A$0,%A$0,2 = "   asl %A-%A.index.min"
rule mul %A$1,%A$1,2 = "   asl %A-%A.index.min+1"
;TODO: This should be rewritten as top level rule
;rule mul %A:card,%A:card,0 = "   lda #0" "   sta %A" "   sta %A+1"
;rule mul %A:card,%A:card,1 = "   ;"

;ROL, ROR

;TODO: Support void (this optimisation should be in compiler)
rule ror a,a,0 = "   ;"
rule ror a,a,1 = "   ror"
rule ror %A:byte,%A:byte,0 = "   ;"
rule ror %A:byte,%A:byte,1 = "   ror %A"
rule ror %A$const %B,%A(%B),1 = "   ror %A-%A.index.min+%B"

rule rol a,a,0 = "   ;"
rule rol a,a,1 = "   rol"
rule rol %A:byte,%A:byte,0 = "   ;"
rule rol %A:byte,%A:byte,1 = "   rol %A"
rule rol %A$0,%A$0,1 = "   rol %A-%A.index.min"
rule rol %A$const %B,%A(%B),1 = "   rol %A-%A.index.min+%B"
;rule rol %A:byte$1,%A:byte$1,1 = "   rol %A+1"


;SBC, DEX, DEY, DEC

rule sub as,ac,const %A:byte1  = "   sbc #%A"
rule sub as,ac, %A$const %B    = "   sbc %A-%A.index.min+%B"
rule sub as,ac,%A:byte1 = "   sbc %A"

;TODO: This should be removed (there is no such instruction)
;rule sub a,a,const %A:byte1  = "   sbc #%A"
;rule sub a,a,%A:byte1 = "   sbc %A"
rule sub x,x,1 = "   dex"
rule sub y,y,1 = "   dey"

rule sub %A:byte1,%A,1 = "   dec %A"

rule sub %A$const %B, %A(%B), 1 = "   dec %A-%A.index.min+%B"

;rule sub a,a,%A$const %B = "   sbc %A-%A.index.min+%B"

;JMP
rule goto @%A$0  = "   jmp (%A)"					;TODO: goto @%A
rule goto %A     = "   jmp %A"

;type interrupt:proc

;rule proc %A:interrupt = "%A .proc" "   pha" "   txa" "   pha" "   tya" "   pha"
;rule endproc %A:interrupt = "   pla" "   tay" "   pla" "   tax" "   pla" "   rti" ".endp"
;rule call %A:interrupt = "failure, cannot call interrupt routine directly"

;Miscelaneous

;alloc takes two arguments: 
;				result		variable to alloc
;				arg1			constant with address (empty, if the address is not specified)

rule vardef %A,%B   = "%A equ %B"
rule vardef %A,%B(%C..%D) = "%A equ %B+%C*%B.elemsize"

rule label %A   = "%A:"
rule proc %A:proc     = "%A .proc"
rule return %A:proc  = "   rts"
rule endproc %A:proc  = ".endp"
rule call %A:proc   = "   jsr %A"
rule call %A = "jsr %A"
;rule arrindex %A:array(byte,byte)(%E..%F), %B, %C  = "%A_lo:  :%C dta l(%A + %E + #*%B)" "%A_hi:  :%C dta h(%A + %E + #*%B)" 
rule arrindex %A:array(byte,byte) of byte,%B,%C    = "%A_lo:  :%C dta l(%A + #*%B)" "%A_hi:  :%C dta h(%A + #*%B)"

;This is definition of procedure, that can be used to output character
system.printchar:proc chr@cpu.a

;system.out will send the data following the call to specified output routine. 
system.print:proc printchar_proc@(cpu.a,cpu.x):adr @_stdbuf @_putchr_proc_adr @cpu.y

_std_print_out:proc @_stdbuf @_putchr_proc_adr @cpu.a @cpu.x @cpu.y
_std_print_adr:proc a@_arr:adr @_arr @_stdbuf @_putchr_proc_adr @cpu.a @cpu.x @cpu.y

std_print:macro = instr
	call _std_print_out

std_format:macro a:adr = instr
	let_adr _arr, a
	call _std_print_adr

;rule print     = instr
;	call std_print
	
;rule format    = instr
;	call _std_print_adr

rule str_arg ,%A,%B:byte  = "   dta b(%B),%'A"
rule var_arg ,%A:byte   = "   dta b(129),a(%A)"
rule var_arg ,%A:card   = "   dta b(130),a(%A)"
rule var_arg ,%A:adr    = "   dta b(130),a(%A)"
rule var_arg ,%A:long   = "   dta b(131),a(%A)"

rule var_arg, %A:sbyte  = "   dta b(129+32), a(%A)"
rule var_arg, %A:int    = "   dta b(130+32), a(%A)"

rule data ,%A    = "   dta b(%A)"
rule align ,%A    = "   .align %A"
rule file ,%A     = "   ins '%A'"
rule org  ,%A     = "   org %A"
rule ptr , %A    = "   dta a(%A)"
rule debug  = "   brk"  "   dta b(0)"
rule line      = ";### %0(%1) %2"

rule include %A = "   icl '%A'"

;compiler rule defines the command line used to compile generated asm source
; %A  defines name of the source code file (including the path) without extension
; %B  extension of resulting binary as defined by platform
; %/  defines path to directory with currently parsed file

rule compiler %A,%B = "["]%/mads["] ["]%A.asm["] -o:["]%A.%B["] -x -l:["]%A.lst["]"
